
# Speedle - 存储扩展

## 概述
Speedle 现在支持两种不同类型的数据存储：文件存储和etcd存储
你可以实现你自己的数据存储（例如：mongodb 等等）

* 请注意数据存储必须支持watch功能

这个文档从头开始一步步指导你如何实现一个Speedle的数据存储。

## step 1: 实现PolicyStoreManager接口

创建一个目录例如“mystore”并进入该目录
创建源代码文件例如mystore.go，并在该文件中实现PolicyStoreManager接口：

Example in store/etcd/etcdStore.go:
```
type Store struct {
    ...
}
func (s *Store) ReadPolicyStore() (*pms.PolicyStore, error) {
  ...
}
func (s *Store) CreateService(service *pms.Service) error {
  ...
}
...
```

请注意“Watch”方法，该方法会监测你数据存储中的修改。本方法需要返回一个StorageChangeChannel对象，每一个存储改变事件（请参考api/pms/types/StoreChangeEvent）都会被送至这个Channel对象。ADS会收到这些改变事件并立刻更新自身的缓存。

## step 2: 编写storeBuilder代码

### 理解Speedle存储配置信息
Speedle从三个不同的地方读取存储配置信息：flags, 环境变量和配置文件

flags有最高的优先级，然后是环境变量，然后是配置文件。这意味着高优先级源中的配置项将覆盖低优先级源中的相同配置项。

存储所有者需要在init函数中提供flags定义，我们使用[pflag](https://github.com/spf13/pflag)来定义flags。

Flags in store/etcd/storeBuilder.go:
```
const (
    IsEmbeddedEtcdFlagName             = "etcdstore-isembedded"
    EmbeddedEtcdDataDirFlagName        = "etcdstore-embeddedDataDir"
    EtcdEndpointFlagName               = "etcdstore-endpoint"
    EtcdKeyPrefixFlagName              = "etcdstore-keyprefix"
    EtcdTLSClientCertFileFlagName      = "etcdstore-tls-cert"
    EtcdTLSClientKeyFileFlagName       = "etcdstore-tls-key"
    EtcdTLSClientTrustedCAFileFlagName = "etcdstore-tls-ca"
    EtcdTLSAllowedCNFlagName           = "etcdstore-tls-allowedCN"
    EtcdTLSServerNameFlagName          = "etcdstore-tls-serverName"
    EtcdTLSCRLFileFlagName             = "etcdstore-tls-crlFile"
    EtcdTLSInsecureSkipVerifyFlagName  = "etcdstore-tls-insecureSkipVerify"

    //default property values
    DefaultKeyPrefix           = "/speedle_ps/"
    DefaultEtcdStoreEndpoint   = "localhost:2379"
    DefaultEtcdStoreKeyPrefix  = "/speedle_ps/"
    DefaultEtcdStoreIsEmbedded = false
)

func init() {
  pflag.String(EtcdEndpointFlagName, DefaultEtcdStoreEndpoint, "Store config: endpoint of etcd store.")
    pflag.String(EtcdKeyPrefixFlagName, DefaultEtcdStoreKeyPrefix, "Store config: key prefix to store speedle policy data in etcd store.")
    pflag.Bool(IsEmbeddedEtcdFlagName, DefaultEtcdStoreIsEmbedded, "Store config: is embedded etcd store or not.")
    pflag.String(EmbeddedEtcdDataDirFlagName, "", "Store config: data dir for embedded etcd store.")
    pflag.String(EtcdTLSClientCertFileFlagName, "", "Store config: etcd x509 client cert.")
    pflag.String(EtcdTLSClientKeyFileFlagName, "", "Store config: etcd x509 client key.")
    pflag.String(EtcdTLSClientTrustedCAFileFlagName, "", "Store config: etcd x509 client CA cert.")
    pflag.String(EtcdTLSAllowedCNFlagName, "", "Store config: etcd x509 allowed CN.")
    pflag.String(EtcdTLSServerNameFlagName, "", "Store config: etcd x509 server name.")
    pflag.String(EtcdTLSCRLFileFlagName, "", "Store config: etcd x509 CRL file.")
    pflag.Bool(EtcdTLSInsecureSkipVerifyFlagName, false, "Store config: etcd x509 insecure skip verify.")
}
```

环境变量名是flag名字的转换结果，规则是:添加一个“SPDL_”前缀，将每个“-”替换为“_”，并将所有字母转换为大写。例如：
"etcdstore-endpoint" -> "SPDL_ETCDSTORE_ENDPOINT"

存储所有者还需要通过提供{flagName:storePropName} map来定义配置文件中使用的存储属性名。这个map将显示flag和store属性之间的对应关系。

Config file example:
```
{
    "storeConfig": {
        "storeType": "etcd",
        "storeProps": {
            "EtcdEndpoint": "localhost:2379",
            "EtcdKeyPrefix": "/opss_ps/",
            "IsEmbeddedEtcd": true,
            "EmbeddedEtcdDataDir": "./speedle.etcd"
        }
    },
}
```

### 实现StoreBuilder接口

StoreBuild将提供关于创建存储的方法，和获取该存储相应参数的方法

Example in store/etcd/storeBuilder.go:
```
type Etcd3StoreBuilder struct{}

func (esb Etcd3StoreBuilder) NewStore(config map[string]interface{}) (pms.PolicyStoreManager, error) {
   ...
}
func (fs FileStoreBuilder) GetStoreParams() map[string]string {
   ...
}
```
NowStore方法需要返回一个实现了PolicyStoreManager接口的存储实例。
输入参数是一个配置map，对应于配置文件中的“storeProps”，它会与来自flags和环境变量的配置合并在一起。
您可以从这个配置map中读取配置项的值来构建存储。如果希望读取“EtcdEndpoint”值，比如像下面这样：
```
etcdEndpoint, ok := config[EtcdEndpointKey].(string)
```
请注意，因为配置值可能来自不同的源(flag、env变量、配置文件)，所以配置值类型可能是您的expect类型(比如int或bool)或string类型。因此，您需要检查值类型，并可能需要将值从string类型转换为expect类型。

接口GetStoreParams()需要返回一个{flagName:storePropName} map。这个map将显示flag和store属性之间的对应关系。

etcd storeBuilder GetStoreParams() example:
```
func (esb Etcd3StoreBuilder) GetStoreParams() map[string]string {
    return map[string]string{

        IsEmbeddedEtcdFlagName:             IsEmbeddedEtcdKey,
        EmbeddedEtcdDataDirFlagName:        EmbeddedEtcdDataDirKey,
        EtcdEndpointFlagName:               EtcdEndpointKey,
        EtcdKeyPrefixFlagName:              EtcdKeyPrefixKey,
        EtcdTLSClientCertFileFlagName:      EtcdTLSClientCertFileKey,
        EtcdTLSClientKeyFileFlagName:       EtcdTLSClientKeyFileKey,
        EtcdTLSClientTrustedCAFileFlagName: EtcdTLSClientTrustedCAFileKey,
        EtcdTLSAllowedCNFlagName:           EtcdTLSAllowedCNKey,
        EtcdTLSServerNameFlagName:          EtcdTLSServerNameKey,
        EtcdTLSCRLFileFlagName:             EtcdTLSCRLFileKey,
        EtcdTLSInsecureSkipVerifyFlagName:  EtcdTLSInsecureSkipVerifyKey,
    }

}
```

### 注册storeBuilder
注册storeBuilder将根据提供的名称使这种类型的存储可用。init函数中需要声明这个存储所需的所有flags。

Example in store/etcd/storeBuilder.go:
```
func init() {
    pflag.String(EtcdEndpointFlagName, DefaultEtcdStoreEndpoint, "Store config: endpoint of etcd store.")
    pflag.Bool(IsEmbeddedEtcdFlagName, DefaultEtcdStoreIsEmbedded, "Store config: is embedded etcd store or not.")
    ...

    store.Register(StoreType, Etcd3StoreBuilder{})
}
```

## step 3: 链接新的存储到Speedle
在目录cmd/speedle-ads和目录cmd/speedle-pms中，你可以找到一个有着以下内容的store.go文件

```
package main

import (
    _ "github.com/oracle/speedle/pkg/store/etcd"
    _ "github.com/oracle/speedle/pkg/store/file"
)
```
在这个文件中，我们使用了side-effect import (使用空白的import名字)来链接每个存储实现。你可以在里面添加你自己的。
如果你想用in-process模式来使用speedle，你可以复制这个store.go文件到你的package中，并且根据需要修改package的名字。
